function [xmin,fmin,nFeval,nRef,nExp,nIC,nOC,nShrink,iter,BestCost] = wANMS(objfnc, xinit, params)
%
% Adaptive Nelder-Mead Simplex Algorithm with Initial Simplex generated by Halton or Sobol distribution
% for solving the unconstrained optimization problem:
%         min f(x).
%
% It uses the improved version of adaptive parameters introduced in the following paper:
%              Fuchang Gao and Lixing Han
% "Implementing the Nelder-Mead simplex algorithm with adaptive parameters"
%  Computational Optimization and Applications, 2012, 51: 259-277.
% It also uses a population generated by Sobol or Halton Sequence to create the initial simplex
%
%  by Korhan Günel
%  coded January, 2019
%
% Inputs:
%   objfnc  : Objective function
%   xinit   : Initial guess
%   params  : Problem paramaters
%
% Outputs:
%   xmin     : Approximate optimal solution
%   fmin     : The function value at xmin
%   nFeval   : # of function evaluations
%   nExp     : # of expansion operations
%   nIC      : # of inside contraction operations
%   nOC      : # of outside contraction operations
%   nShrink  : # of shrink operations
%   BestCost : Best cost value obtained for each iteration

objfnc = fcnchk(objfnc);
nVar = params.dim;
L = 10;
VarMin = params.low;
VarMax = params.up;
maxIter = params.MaxIt;
tol = params.eps; %--tolerance for termination (Recommended value: 10^-4)
maxnFeval = params.maxnFeval; %--maximum number of function evaluations

% % Initialize adaptive parameters
% alpha = 1;
% 
% %% Construct the initial simplex
% leapInd = randi(12);
% skipInd = randi(12);
% Q = qrandstream(method,nVar,'Leap',leapInd,'Skip',skipInd);
% Y = qrand(Q,nPop*nVar);
% fY = zeros(1,nPop*nVar);
% for i=1:nPop*nVar
%     [~, fY(i), ~, ~]  = feval(objfnc, Y(i,:), funId);
% end
% %[~,minInd] = min(fY);
% %x0 = Y(minInd,:);
% [~,I] = sort(fY);
% x0 = Y(I(1),:);
% scaleFactor = min(max(max(abs(x0)),1),10);
% 
% nFeval = nPop*nVar;
% 
% % Detect the farthest point from the vertex x0
% %D = squareform(pdist(Y));
% %[~,maxInd] = max(D(I(1),:));
% 
% 
% X = zeros(nVar+1, nVar);
% fX = zeros(1, nVar+1);
% X(1,:) = x0;
% fX(1) = fY(I(1));
% for i=2:nVar+1
%     %scaleFactor = VarMin + (VarMax - VarMin)*rand;
%     %scaleFactor = 1 + (10 - 1)*rand;
%     %X(i,:) = x0 + scaleFactor*x0;
%     X(i,:) = x0 + scaleFactor*Y(I(i),:);
%     X(i,:) =  max(X(i,:),VarMin);
%     X(i,:) = min(X(i,:),VarMax);
%     [~, fX(i), ~, ~] = feval(objfnc, X(i,:), funId);
% end
% nFeval = nFeval + nVar+1;
% % Insert the farthest point to into the set of vertices
% %X(nVar+1,:) = Y(maxInd,:);
% %fX(nVar+1) = fY(maxInd);
% [fX,I] = sort(fX);
% X = X(I,:);

% Create initial simplex
X = VarMin + (VarMax - VarMin)*rand(nVar,nVar);
X(nVar+1,:) = xinit;
fX=zeros(1,nVar+1);
for i=1:nVar+1
     fX(i) = feval(objfnc, X(i,:));
end
nFeval=nVar+1;
[fX,I]=sort(fX);
X=X(I,:);

%% Nelder-Mead with Weighted Means 
BestCost = zeros(1,maxIter);
nRef = 0; nExp = 0; nIC = 0; nOC =0; nShrink = 0;
calpha = 0; cbeta = 0; cgamma1 = 0; cgamma2 = 0; cdelta = 0; 
for iter = 1:maxIter
    
     if max(max(abs(X(2:nVar+1,:) - X(1:nVar,:)))) <= eps
         % Stopping criterion : Check diameter is equal or less than the tolerance value
         break;
     end
    
     if nFeval > maxnFeval
         % Stopping criterion
         break;
     end
       
    % Centroid of the best vertices
     w = (2*(nVar-(1:nVar))+1)/(nVar^2);
     M = mean(w.*X(1:nVar,:));

    % Initialize adaptive parameters
    alpha = 1;
    gamma1 = 0.75 + 0.1/(1+cgamma1);
    gamma2 = 0.5 - 0.1/(1+cgamma2);
    delta = 0.5 + 0.1/(1+cdelta);
    term = (nVar^2 - w.*(nVar-w))./(w.*(nVar-w));

    if iscolumn(term)
        beta =  term';
    else
        beta = term;
    end
    % Reflection point
    R = reflection(alpha,M,X(nVar+1,:));
    fR = feval(objfnc, R);
    nRef = nRef+1;
    nFeval = nFeval + 1;
    if fR < fX(1)
        % Update parameter for expansion point
        E = expansion(beta,M,R);
        fE = feval(objfnc, E);
        nFeval = nFeval + 1;
        nExp = nExp + 1;
        if fE < fR
            X(nVar+1,:) = E;
            fX(nVar+1) = fE;
            cbeta = cbeta + 1;
        else
            X(nVar+1,:) = R;
            fX(nVar+1) = fR;
            calpha= calpha + 1;
        end
    else
        if fR < fX(nVar)
            % accept reflection point
            X(nVar+1,:) = R;
            fX(nVar+1) = fR;
            calpha = calpha + 1;
        else
            if fR < fX(nVar+1)
                % Update parameter for Outside Contraction point
                OC = outsideContraction(gamma1,M,R);
                fOC = feval(objfnc, OC);
                nFeval = nFeval + 1;
                nOC = nOC + 1;
                if fOC <= fR
                    X(nVar+1,:) = OC;
                    fX(nVar+1) = fOC;
                    cgamma1 = cgamma1 + 1;
                else
                    % Shrink
                    for i=2:nVar+1
                        % Update parameter for shrink point
                        S = shrink(delta,X(1,:),X(i,:));
                        fS = feval(objfnc, S);
                        nFeval = nFeval + 1;
                        X(i,:) = S;
                        fX(i) = fS;
                    end
                    nShrink = nShrink + nVar;
                    cdelta = cdelta+1;
                end
            else
                % Update parameter for Inside Contraction point
                IC = insideContraction(gamma2,M,R);
                fIC = feval(objfnc, IC);
                nFeval = nFeval + 1;
                nIC = nIC + 1;
                if fIC < fX(nVar+1)
                    X(nVar+1,:) = IC;
                    fX(nVar+1) = fIC;
                    cgamma2 = cgamma2 + 1;
                else
                    % Shrink
                    for i=2:nVar+1
                        % Update parameter for shrink point
                        S = shrink(delta,X(1,:),X(i,:));
                        fS = feval(objfnc, S);
                        nFeval = nFeval + 1;
                        X(i,:) = S;
                        fX(i) = fS;
                    end
                    nShrink = nShrink + nVar;
                    cdelta = cdelta+1;
                end
            end
        end
    end
    [fX,I] = sort(fX);
    X = X(I,:);
    BestCost(iter) = fX(1);
    
    if (iter>L) && (BestCost(iter)== BestCost(iter-L))
        X(nVar+1,:) = VarMin + (VarMax - VarMin)*rand(1,nVar);
        fX(nVar+1) =feval(objfnc, X(nVar+1,:));
    end
    
    [fX,I] = sort(fX);
    X = X(I,:);
    BestCost(iter) = fX(1);
    
%     if mod(iter,100)==0
    fprintf('\tIteration %3d > Best Cost = %8.6e\n', iter, BestCost(iter));
%     end
end
xmin = X(1,:);
fmin = fX(1);